# Parallel-And-Distributed-HW1

The algorithm implemented in HW1.cpp is a modified version of the prime sieve of Eratosthenes.

A short description of the classic sieve of Eratosthenes algorithm is as follows. We keep a table of booleans specifying wether or not each number at its corresponding index is prime or not. We initialize the table to have every number set to true, i.e. "yes it is prime". We then sweep through every number in order of smallest to largest from 2 to the maximum value, perhaps casing out 0 and 1 as not prime. If this number still has its original value of true, then we know it must be prime because if it were not, we would have encountered it as a multiple of its smallest prime in an earlier iteration. Once we know this number is prime, we will loop over all of its multiples and set these said multiples to false. At the end of the algorithm, we are left with an accurate isPrime table.

There are only a few changes made to this original algorithm in my parallelized version. The first thing is that the numbers are not looped over in perfect order. Each thread is assigned every (NUM_THREADS)th odd number, each next thread's numbers staggered one odd number from the last. For instance, if we had 3 threads, the assignment would be as follows: (thread0: 3, 9, 15, 21, 27, ...), (thread1: 5, 11, 17, 23, 29, ...), (thread2: 7, 13, 19, 25, 31, ...). We will also case out 2 as it is the only even prime. This means that we cannot guarantee that only the multiples of the primes are getting knocked out, i.e. we might be looping over multiples of composite numbers. However, this does not change the accuracy of the algorithm, only the correctness. The multiples of each composite will also be composite. If we find a number to be already set to composite in the for loop, then we can not worry about looping over its multiples, as we will be sure to loop over all multiples of every prime, we just might include some composites in there as well.

The efficiency of this algorithm is still fair. For the most part, the algorithm is knocking out multiples of small numbers earlier than the multiples of large numbers. Each thread works on its list of odd numbers in increasing order, and the staggering should allow the multi-threading to work together to keep the numbers that are being worked on in a somewhat sorted order, i.e., in the example of thread number assignments in the paragraph above, the 9 from thread0 will more than likely be considered before the 31 from thread2.

Running it against a normal single-threaded sieve algorithm, it is roughly a little more than twice as efficient.
